// ==UserScript==
// @name         SUKI¬¥s Modpack
// @namespace    http://tampermonkey.net/
// @version      2025-11-22
// @description  Big narrow one modpack created by suki.
// @author       SUKI ‚úî
// @match        https://narrow.one/*
// @icon         https://static.wikia.nocookie.net/archery-narrow-one/images/7/70/Shooooovel.gif/revision/latest/scale-to-width-down/600?cb=20230415043125
// @grant        none
// ==/UserScript==


// SCRIPT START

(function() {
    'use strict';

    const DEBUG = true;

    // Logging function for debugging
    function log(...args) {
        if (DEBUG) {
            console.log('[Sky Modifier]', ...args);
        }
    }

    // Store all color-related uniforms
    const colorUniforms = new Set();

    // Target color for modification

    //CHANGE THE COLOR HERE
    //CHANGE THE COLOR HERE
    //CHANGE THE COLOR HERE
    //CHANGE THE COLOR HERE
    //CHANGE THE COLOR HERE

    const TARGET_COLOR = [0, 0, 0]; // Dark mode

    //CHANGE THE COLOR HERE
    //CHANGE THE COLOR HERE
    //CHANGE THE COLOR HERE
    //CHANGE THE COLOR HERE

    let originalFunctions = {
        getContext: HTMLCanvasElement.prototype.getContext,
        getUniformLocation: null,
        uniform3f: null,
        uniform4f: null,
        uniform3fv: null,
        uniform4fv: null
    };

    let lastContext = null;

    // Check if the values are in the color range (0-1)
    function isColorValue(v1, v2, v3) {
        return [v1, v2, v3].every(v => v >= 0 && v <= 1);
    }

    // Intercept and modify uniform location fetching
    function handleGetUniformLocation(context) {
        const original = context.getUniformLocation;
        originalFunctions.getUniformLocation = original;

        return function(program, name) {
            const location = original.apply(this, arguments);
            return location;
        };
    }

    // Intercept and modify uniform3f function
    function handleUniform3f(context) {
        const original = context.uniform3f;
        originalFunctions.uniform3f = original;

        return function(location, v1, v2, v3) {
            if (isColorValue(v1, v2, v3)) {
                log(`Found color uniform: [${v1}, ${v2}, ${v3}]`);
                colorUniforms.add(location);
                return original.call(this, location, ...TARGET_COLOR);
            }
            return original.apply(this, arguments);
        };
    }

    // Intercept and modify uniform4f function
    function handleUniform4f(context) {
        const original = context.uniform4f;
        originalFunctions.uniform4f = original;

        return function(location, v1, v2, v3, v4) {
            if (isColorValue(v1, v2, v3)) {
                log(`Found color uniform4f: [${v1}, ${v2}, ${v3}, ${v4}]`);
                colorUniforms.add(location);
                return original.call(this, location, ...TARGET_COLOR, v4);
            }
            return original.apply(this, arguments);
        };
    }

    // Intercept and modify uniform3fv function
    function handleUniform3fv(context) {
        const original = context.uniform3fv;
        originalFunctions.uniform3fv = original;

        return function(location, value) {
            if (value.length === 3 && isColorValue(...value)) {
                log(`Found color uniform3fv: [${value}]`);
                colorUniforms.add(location);
                return original.call(this, location, new Float32Array(TARGET_COLOR));
            }
            return original.apply(this, arguments);
        };
    }

    // Intercept and modify uniform4fv function
    function handleUniform4fv(context) {
        const original = context.uniform4fv;
        originalFunctions.uniform4fv = original;

        return function(location, value) {
            if (value.length === 4 && isColorValue(value[0], value[1], value[2])) {
                log(`Found color uniform4fv: [${value}]`);
                colorUniforms.add(location);
                return original.call(this, location, new Float32Array([...TARGET_COLOR, value[3]]));
            }
            return original.apply(this, arguments);
        };
    }

    // Hook WebGL functions to modify uniforms
    function hookWebGL() {
        log('Injecting WebGL Hook');

        HTMLCanvasElement.prototype.getContext = function() {
            const context = originalFunctions.getContext.apply(this, arguments);

            if ((arguments[0] === 'webgl' || arguments[0] === 'webgl2') && !context._hooked) {
                log('Creating WebGL context');
                lastContext = context;

                if (!context._hooked) {
                    context.getUniformLocation = handleGetUniformLocation(context);
                    context.uniform3f = handleUniform3f(context);
                    context.uniform4f = handleUniform4f(context);
                    context.uniform3fv = handleUniform3fv(context);
                    context.uniform4fv = handleUniform4fv(context);
                    context._hooked = true;
                    log('Hooking complete');
                }
            }

            return context;
        };
    }

    // Periodically reset uniforms if necessary
    function setupPeriodicCheck() {
        setInterval(() => {
            if (lastContext && colorUniforms.size > 0) {
                for (const location of colorUniforms) {
                    lastContext.uniform3f(location, ...TARGET_COLOR);
                    lastContext.uniform4f(location, ...TARGET_COLOR, 1.0);
                }
            }
        }, 100);
    }

    // Initialize the script
    function initialize() {
        try {
            log('Script initialization started');
            hookWebGL();
            setupPeriodicCheck();

            unsafeWindow.resetSkyColor = function() {
                log('Manually reset sky color');
                if (lastContext && colorUniforms.size > 0) {
                    for (const location of colorUniforms) {
                        lastContext.uniform3f(location, ...TARGET_COLOR);
                        lastContext.uniform4f(location, ...TARGET_COLOR, 1.0);
                    }
                }
            };

            document.addEventListener('visibilitychange', function() {
                if (!document.hidden) {
                    unsafeWindow.resetSkyColor();
                }
            });

            log('Initialization completed');
        } catch (error) {
            console.error('[Sky Modifier] Initialization failed:', error);
        }
    }

    initialize();
})();

(function() {
    'use strict';

    const replacementTable = {
        "static/img/hudIcons/flagRed.svg": "https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Roter-punkt.svg/1200px-Roter-punkt.svg.png",
        "static/img/hudIcons/flagBlue.svg": "https://upload.wikimedia.org/wikipedia/commons/thumb/f/fc/Blauer-punkt.svg/768px-Blauer-punkt.svg.png",
        "static/img/hudIcons/playerIcon.svg": "https://i.ibb.co/8gSvdPm/player-removebg-preview.png",
    }
    const originalSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, "src");
    Object.defineProperty(HTMLImageElement.prototype, "src", {
        set(value) {
            //console.log(value); // uncomment to determine what the values should be
            if (replacementTable[value]) this.crossOrigin = "anonymous";
            originalSrcDescriptor.set.call(this, replacementTable[value] ?? value);
        },
        get() {
            return originalSrcDescriptor.get.call(this);
        }
    });
})();

(function() {
    'use strict';

    let isShiftDown = false;
    console.log('CSSÁº©ÊîæFOVËÑöÊú¨(SHIFTÁâà)ÂºÄÂßãËøêË°å...');

    function findGameCanvas() {
        const canvases = document.querySelectorAll('canvas');
        for (const canvas of canvases) {
            if (canvas.width > 500 && canvas.height > 300) {
                return canvas;
            }
        }
        return canvases[0];
    }

    function applyZoom(scale) {
        const canvas = findGameCanvas();
        if (!canvas) return;

        if (scale === 1.0) {
            canvas.style.transform = '';
            canvas.style.transformOrigin = '';
        } else {
            canvas.style.transform = `scale(${scale})`;
            canvas.style.transformOrigin = 'center center';
        }
    }

    function handleKeyDown(event) {
        if (event.key === 'Shift' && !isShiftDown) {
            console.log('ShiftÈîÆÊåâ‰∏ãÔºåÂ∫îÁî®1.75ÂÄçÁº©Êîæ');
            isShiftDown = true;
            applyZoom(1.75);
        }
    }

    function handleKeyUp(event) {
        if (event.key === 'Shift' && isShiftDown) {
            console.log('ShiftÈîÆÊùæÂºÄÔºåÊÅ¢Â§çÊ≠£Â∏∏');
            isShiftDown = false;
            applyZoom(1.0);
        }
    }

    function handleBlur() {
        if (isShiftDown) {
            console.log('Á™óÂè£Â§±ÂéªÁÑ¶ÁÇπÔºåÊÅ¢Â§çÊ≠£Â∏∏');
            isShiftDown = false;
            applyZoom(1.0);
        }
    }

    function init() {
        console.log('ÂàùÂßãÂåñCSSÁº©ÊîæFOV(SHIFTÁâà)...');

        document.addEventListener('keydown', handleKeyDown, true);
        document.addEventListener('keyup', handleKeyUp, true);
        window.addEventListener('blur', handleBlur);

        console.log('CSSÁº©ÊîæFOV(SHIFTÁâà)ÂàùÂßãÂåñÂÆåÊàê');
    }

    init();
})();

(function () {
    'use strict';

    let lastStats = { kills: 0, deaths: 0 };
    let lastKDLevel = 0;
    let isDragging = false;
    let offsetX = 0, offsetY = 0;

    // KD milestone thresholds and their colors
    const kdLevels = [
        { threshold: 2, color: 'darkgreen', message: 'KD Reached 2!' },
        { threshold: 3, color: 'darkblue', message: 'KD Reached 3!' },
        { threshold: 5, color: 'black', message: 'KD Reached 5!' },
        { threshold: 10, color: 'gold', message: 'KD Reached 10!' },
        { threshold: 50, color: '#51035e', message: 'KD Reached 50!' }
    ];

    function createKDUI() {
        const div = document.createElement('div');
        div.id = 'kd-hud';
        div.innerHTML = `Kills: 0 / Deaths: 0 (K/D: 0.00)`;
        Object.assign(div.style, {
            position: 'fixed',
            top: '10px',
            left: '50%',
            transform: 'translateX(-50%)',
            background: 'rgba(0, 0, 0, 0.7)',
            color: '#fff',
            padding: '8px 16px',
            fontSize: '16px',
            fontFamily: 'Bebas Neue, sans-serif',
            borderRadius: '8px',
            zIndex: 9999,
            boxShadow: '0 0 10px rgba(255,255,255,0.2)',
            cursor: 'move',
            userSelect: 'none',
            transition: 'all 0.5s ease-out'
        });

        // Make draggable
        div.addEventListener('mousedown', (e) => {
            isDragging = true;
            offsetX = e.clientX - div.getBoundingClientRect().left;
            offsetY = e.clientY - div.getBoundingClientRect().top;
            div.style.cursor = 'grabbing';
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            div.style.cursor = 'move';
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                e.preventDefault();
                div.style.left = `${e.clientX - offsetX}px`;
                div.style.top = `${e.clientY - offsetY}px`;
                div.style.transform = 'none';
            }
        });

        document.body.appendChild(div);
    }

    function showCelebration(message, color) {
        const celebration = document.createElement('div');
        celebration.textContent = message;
        Object.assign(celebration.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            fontSize: '48px',
            fontWeight: 'bold',
            color: color,
            textShadow: '0 0 10px rgba(255,255,255,0.7)',
            zIndex: 10000,
            opacity: '0',
            transition: 'all 1s ease-in-out',
            whiteSpace: 'nowrap'
        });
        document.body.appendChild(celebration);

        // Animate in
        setTimeout(() => {
            celebration.style.opacity = '1';
            celebration.style.transform = 'translate(-50%, -50%) scale(1.2)';
        }, 10);

        // Animate out after 3 seconds
        setTimeout(() => {
            celebration.style.opacity = '0';
            celebration.style.transform = 'translate(-50%, -50%) scale(0.8)';

            // Remove element after animation
            setTimeout(() => {
                celebration.remove();
            }, 1000);
        }, 3000);
    }

    function updateKDUI(kills, deaths) {
        const div = document.getElementById('kd-hud');
        if (!div) return;

        const kd = deaths === 0 ? kills : (kills / deaths).toFixed(2);
        div.textContent = `Kills: ${kills} / Deaths: ${deaths} (K/D: ${kd})`;

        // Calculate current KD level
        const kdValue = deaths === 0 ? kills : kills/deaths;
        let currentLevel = 0;
        let celebrationMessage = '';
        let celebrationColor = '';

        // Check if we reached a new milestone
        for (let i = kdLevels.length - 1; i >= 0; i--) {
            if (kdValue >= kdLevels[i].threshold) {
                currentLevel = kdLevels[i].threshold;
                if (currentLevel > lastKDLevel) {
                    celebrationMessage = kdLevels[i].message;
                    celebrationColor = kdLevels[i].color;
                    lastKDLevel = currentLevel;
                }
                break;
            }
        }

        // Update colors and show celebration if needed
        if (celebrationMessage) {
            // Pulse animation
            div.style.animation = 'pulse 0.5s 3';

            // Show celebration message
            showCelebration(celebrationMessage, celebrationColor);

            // Set the new color
            setTimeout(() => {
                div.style.background = celebrationColor;
                div.style.color = 'white';
                div.style.boxShadow = `0 0 20px ${celebrationColor}`;
            }, 1500);
        } else if (kdValue < 2) {
            // Reset to default if below all thresholds
            div.style.background = 'rgba(0, 0, 0, 0.7)';
            div.style.color = '#fff';
            div.style.boxShadow = '0 0 10px rgba(255,255,255,0.2)';
            lastKDLevel = 0;
        }
    }

    // Add pulse animation to style
    const style = document.createElement('style');
    style.textContent = `
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        #kd-hud {
            transition: all 0.5s ease-out, background 0.5s ease-out, box-shadow 0.5s ease-out;
        }
    `;
    document.head.appendChild(style);

    function getPlayerStats() {
        const meRow = [...document.querySelectorAll('.playersListItem')]
            .find(row => row.querySelector('.players-list-label')?.textContent.includes('You'));

        if (!meRow) return null;

        const scoreCells = meRow.querySelectorAll('.playersListItemScore');
        const kills = parseInt(scoreCells[1]?.textContent || '0');
        const deaths = parseInt(scoreCells[2]?.textContent || '0');

        return { kills, deaths };
    }

    function tick() {
        const stats = getPlayerStats();
        if (!stats) return;

        if (stats.kills !== lastStats.kills || stats.deaths !== lastStats.deaths) {
            lastStats = stats;
            updateKDUI(stats.kills, stats.deaths);
        }
    }

    function init() {
        createKDUI();
        setInterval(tick, 1000);
    }

    window.addEventListener('load', () => setTimeout(init, 2000));
})();

(function () {
    'use strict';

    const DB_NAME = "keyValuesDb";
    const STORE_NAME = "keyValues";
    const KEY_NAME = "cachedProfileState";

    const WIN_PERCENTAGE_ICONS = {
        light: "https://raw.githubusercontent.com/RiptideN1/Mods/main/lightmodetrophy.png",
        dark: "https://raw.githubusercontent.com/RiptideN1/Mods/main/Trophy-profile-stat-icon.png"
    };

    const KD_RATIO_ICONS = {
        light: "https://play-lh.googleusercontent.com/q5_pVBlB4d4aUecTCfwEaGtuQsLs8S0lFnFk0_K3kAxtbAmMDb_UtCA0rAXA7Uj3x0s=w600-h300-pc0xffffff-pd", // Default crosshair icon
        dark: "https://play-lh.googleusercontent.com/q5_pVBlB4d4aUecTCfwEaGtuQsLs8S0lFnFk0_K3kAxtbAmMDb_UtCA0rAXA7Uj3x0s=w600-h300-pc0xffffff-pd" // Same icon for both themes
    };

    let lastProfileJSON = null;

    function getProfileState() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME);
            request.onerror = () => reject("Failed to open IndexedDB");
            request.onsuccess = () => {
                const db = request.result;
                const transaction = db.transaction(STORE_NAME, 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const getRequest = store.get(KEY_NAME);
                getRequest.onerror = () => reject("Failed to get data");
                getRequest.onsuccess = () => resolve(getRequest.result);
            };
        });
    }

    function isValidProfile(profile) {
        return profile &&
            profile.stats &&
            typeof profile.stats.gamesPlayed === 'number' &&
            typeof profile.stats.gamesWon === 'number' &&
            typeof profile.stats.kills === 'number' &&
            typeof profile.stats.deaths === 'number';
    }

    function applyThemeAwareIcon(icon, iconSet) {
        function updateIcon() {
            const isDark = document.documentElement.classList.contains('theme-dark');
            icon.style.background = `url("${isDark ? iconSet.dark : iconSet.light}") no-repeat center center`;
            icon.style.backgroundSize = 'contain';
            icon.style.filter = 'none';
            icon.style.width = '48px';
            icon.style.height = '48px';
        }
        updateIcon();
        const observer = new MutationObserver(updateIcon);
        observer.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ['class']
        });
    }

    function createOrUpdateStats(profileStats) {
        const profileStatsContainer = document.querySelector('.profile-stats');
        if (!profileStatsContainer) return false;

        // Win Percentage Stat
        let winPercentageWrapper = profileStatsContainer.querySelector('.win-percentage');
        if (!winPercentageWrapper) {
            winPercentageWrapper = document.createElement('div');
            winPercentageWrapper.className = 'wrinkledPaper profile-stat win-percentage';
            winPercentageWrapper.style.setProperty('--wrinkled-paper-seed', Math.floor(Math.random() * 99999));

            const icon = document.createElement('div');
            icon.className = 'profile-stat-icon';
            winPercentageWrapper.appendChild(icon);

            const label = document.createElement('div');
            label.textContent = 'Win Percentage';
            winPercentageWrapper.appendChild(label);

            const value = document.createElement('div');
            value.className = 'win-percentage-value';
            winPercentageWrapper.appendChild(value);

            profileStatsContainer.appendChild(winPercentageWrapper);
            applyThemeAwareIcon(icon, WIN_PERCENTAGE_ICONS);
        }

        // K/D Ratio Stat
        let kdRatioWrapper = profileStatsContainer.querySelector('.kd-ratio');
        if (!kdRatioWrapper) {
            kdRatioWrapper = document.createElement('div');
            kdRatioWrapper.className = 'wrinkledPaper profile-stat kd-ratio';
            kdRatioWrapper.style.setProperty('--wrinkled-paper-seed', Math.floor(Math.random() * 99999));

            const icon = document.createElement('div');
            icon.className = 'profile-stat-icon';
            kdRatioWrapper.appendChild(icon);

            const label = document.createElement('div');
            label.textContent = 'K/D Ratio';
            kdRatioWrapper.appendChild(label);

            const value = document.createElement('div');
            value.className = 'kd-ratio-value';
            kdRatioWrapper.appendChild(value);

            profileStatsContainer.appendChild(kdRatioWrapper);
            applyThemeAwareIcon(icon, KD_RATIO_ICONS);
        }

        // Update values
        const winPercentageValue = winPercentageWrapper.querySelector('.win-percentage-value');
        const kdRatioValue = kdRatioWrapper.querySelector('.kd-ratio-value');

        if (winPercentageValue) {
            const winPercentage = profileStats.gamesPlayed > 0
                ? (profileStats.gamesWon / profileStats.gamesPlayed) * 100
                : 0;
            winPercentageValue.textContent = `${winPercentage.toFixed(2)}%`;
        }

        if (kdRatioValue) {
            const kdRatio = profileStats.deaths > 0
                ? profileStats.kills / profileStats.deaths
                : profileStats.kills; // If no deaths, show kills count
            kdRatioValue.textContent = kdRatio.toFixed(2);
        }

        return true;
    }

    async function pollAndUpdate() {
        try {
            const profileState = await getProfileState();
            const profile = profileState ? (profileState.value || profileState) : null;
            if (!isValidProfile(profile)) return;

            const profileJSON = JSON.stringify(profile.stats);
            if (profileJSON !== lastProfileJSON) {
                lastProfileJSON = profileJSON;
                createOrUpdateStats(profile.stats);
            }
        } catch (e) {
            console.error("Error updating stats:", e);
        }
    }

    function observeProfileStatsPresence() {
        const bodyObserver = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                for (const node of mutation.addedNodes) {
                    if (!(node instanceof HTMLElement)) continue;
                    if (node.matches && (node.matches('.profile-stats') ||
                        node.querySelector('.profile-stats'))) {
                        lastProfileJSON = null;
                        pollAndUpdate();
                    }
                }
            }
        });

        bodyObserver.observe(document.body, { childList: true, subtree: true });
    }

    function start() {
        pollAndUpdate();
        setInterval(pollAndUpdate, 2000);
        observeProfileStatsPresence();
    }

    if (document.readyState === 'loading') {
        window.addEventListener('DOMContentLoaded', start);
    } else {
        start();
    }
})();

(function () {
    'use strict';

    const MAX_SECONDS = 60;
    let mediaRecorder;
    let recordedChunks = [];
    let isRecording = false;
    let canvasStream = null;

    // UI Elements
    const startBtn = document.createElement('button');
    const saveBtn = document.createElement('button');
    const statusBox = document.createElement('div');

    Object.assign(startBtn.style, {
        position: 'fixed', top: '10px', right: '180px', zIndex: 9999,
        padding: '8px 12px', background: '#222', color: 'white',
        border: 'none', borderRadius: '6px', cursor: 'pointer',
        fontSize: '14px', fontFamily: 'sans-serif'
    });
    startBtn.textContent = "‚ñ∂Ô∏è Start (R)";

    Object.assign(saveBtn.style, {
        position: 'fixed', top: '10px', right: '10px', zIndex: 9999,
        padding: '8px 12px', background: '#444', color: 'white',
        border: 'none', borderRadius: '6px', cursor: 'pointer',
        fontSize: '14px', fontFamily: 'sans-serif'
    });
    saveBtn.textContent = "üé• Save (H)";
    saveBtn.disabled = true;

    Object.assign(statusBox.style, {
        position: 'fixed', top: '50px', right: '10px', zIndex: 9999,
        color: '#fff', background: '#000a', padding: '4px 8px',
        borderRadius: '4px', fontSize: '12px', fontFamily: 'monospace'
    });

    document.body.appendChild(startBtn);
    document.body.appendChild(saveBtn);
    document.body.appendChild(statusBox);

    function updateStatus(msg) {
        statusBox.textContent = msg;
    }

    function setupRecorder(canvas) {
        canvasStream = canvas.captureStream(30);
        mediaRecorder = new MediaRecorder(canvasStream, {
            mimeType: 'video/webm; codecs=vp8',
            videoBitsPerSecond: 2500000
        });

        recordedChunks = [];

        mediaRecorder.ondataavailable = function (e) {
            if (e.data.size > 0) {
                recordedChunks.push(e.data);
                if (recordedChunks.length > MAX_SECONDS) recordedChunks.shift();
            }
        };

        mediaRecorder.start(1000);
        isRecording = true;
        saveBtn.disabled = false;
        updateStatus("üî¥ Recording (up to 60s)...");

        console.warn("[Replay Recorder] Only canvas (game) is recorded. DOM overlays (kill feed, names) are NOT captured.");
    }

    function stopAndSave() {
        if (!isRecording) return;

        mediaRecorder.stop();
        isRecording = false;
        saveBtn.disabled = true;
        updateStatus("üíæ Saving clip...");

        const blob = new Blob(recordedChunks, { type: 'video/webm' });

        const now = new Date();
        const name = `n1-clip-${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}-${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}${String(now.getSeconds()).padStart(2,'0')}.webm`;

        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = name;
        a.click();

        updateStatus("‚úÖ Saved. Press R to record again.");
        console.log(`[Replay Recorder] Saved as ${name}`);
    }

    // Event bindings
    startBtn.onclick = () => {
        if (!isRecording) {
            const canvas = document.querySelector('canvas');
            if (canvas && canvas.captureStream) {
                setupRecorder(canvas);
            } else {
                alert("Canvas not found. Game might not be loaded yet.");
            }
        }
    };

    saveBtn.onclick = stopAndSave;

    document.addEventListener('keydown', e => {
        if (e.key.toLowerCase() === 'r' && !isRecording) {
            const canvas = document.querySelector('canvas');
            if (canvas && canvas.captureStream) {
                setupRecorder(canvas);
            }
        }
        if (e.key.toLowerCase() === 'h' && isRecording) {
            stopAndSave();
        }
    });

    updateStatus("‚è∏Ô∏è Idle. Press R or Start.");
})();

(function() {
    'use strict';

    const DEBUG = true;

    function log(...args) {
        if (DEBUG) {
            console.log('[È¢úËâ≤‰øÆÊîπÂô®]', ...args);
        }
    }

    const uniformInfo = new Map();
    const TARGET_COLOR = [0, 0, 0]; // ÈªëËâ≤

    // ÈúÄË¶Å‰øÆÊîπÁöÑuniformÂêçÁß∞
    const TARGET_UNIFORMS = {
        sky: ['skyHighCol', 'skyMidCol', 'skyLowCol'],
        hit: ['hitFlashTimes[0]', 'hitFlashPositions[0]'],
        bow: ['bowMorphAmount']
    };

    let originalFunctions = {
        getContext: HTMLCanvasElement.prototype.getContext,
        getUniformLocation: null,
        uniform3f: null,
        uniform4f: null,
        uniform3fv: null,
        uniform4fv: null
    };

    function handleGetUniformLocation(context) {
        const original = context.getUniformLocation;
        originalFunctions.getUniformLocation = original;

        return function(program, name) {
            const location = original.apply(this, arguments);
            if (location) {
                uniformInfo.set(location, {
                    name: name,
                    type: Object.entries(TARGET_UNIFORMS).find(([type, names]) =>
                        names.includes(name))?.[0] || 'other'
                });
            }
            return location;
        };
    }

    function handleUniform3f(context) {
        const original = context.uniform3f;
        originalFunctions.uniform3f = original;

        return function(location, v1, v2, v3) {
            const info = uniformInfo.get(location);
            if (info && Object.values(TARGET_UNIFORMS).flat().includes(info.name)) {
                log(`‰øÆÊîπÈ¢úËâ≤ [${info.type}]: ${info.name} [${v1}, ${v2}, ${v3}] -> [0,0,0]`);
                return original.call(this, location, ...TARGET_COLOR);
            }
            return original.apply(this, arguments);
        };
    }

    function handleUniform4f(context) {
        const original = context.uniform4f;
        originalFunctions.uniform4f = original;

        return function(location, v1, v2, v3, v4) {
            const info = uniformInfo.get(location);
            if (info && Object.values(TARGET_UNIFORMS).flat().includes(info.name)) {
                log(`‰øÆÊîπÈ¢úËâ≤ [${info.type}]: ${info.name} [${v1}, ${v2}, ${v3}, ${v4}] -> [0,0,0,${v4}]`);
                return original.call(this, location, ...TARGET_COLOR, v4);
            }
            return original.apply(this, arguments);
        };
    }

    function handleUniform3fv(context) {
        const original = context.uniform3fv;
        originalFunctions.uniform3fv = original;

        return function(location, value) {
            const info = uniformInfo.get(location);
            if (info && Object.values(TARGET_UNIFORMS).flat().includes(info.name)) {
                log(`‰øÆÊîπÈ¢úËâ≤ [${info.type}]: ${info.name} [${value}] -> [0,0,0]`);
                return original.call(this, location, new Float32Array(TARGET_COLOR));
            }
            return original.apply(this, arguments);
        };
    }

    function handleUniform4fv(context) {
        const original = context.uniform4fv;
        originalFunctions.uniform4fv = original;

        return function(location, value) {
            const info = uniformInfo.get(location);
            if (info && Object.values(TARGET_UNIFORMS).flat().includes(info.name)) {
                log(`‰øÆÊîπÈ¢úËâ≤ [${info.type}]: ${info.name} [${value}] -> [0,0,0,${value[3]}]`);
                return original.call(this, location, new Float32Array([...TARGET_COLOR, value[3]]));
            }
            return original.apply(this, arguments);
        };
    }

    function hookWebGL() {
        log('ÂºÄÂßãÊ≥®ÂÖ•WebGLÈí©Â≠ê');

        HTMLCanvasElement.prototype.getContext = function() {
            const context = originalFunctions.getContext.apply(this, arguments);

            if ((arguments[0] === 'webgl' || arguments[0] === 'webgl2') && !context._hooked) {
                log('ÂàõÂª∫WebGL‰∏ä‰∏ãÊñá');

                if (!context._hooked) {
                    context.getUniformLocation = handleGetUniformLocation(context);
                    context.uniform3f = handleUniform3f(context);
                    context.uniform4f = handleUniform4f(context);
                    context.uniform3fv = handleUniform3fv(context);
                    context.uniform4fv = handleUniform4fv(context);
                    context._hooked = true;
                    log('Èí©Â≠êÊ≥®ÂÖ•ÂÆåÊàê');
                }
            }

            return context;
        };
    }

    function initialize() {
        try {
            log('ËÑöÊú¨ÂºÄÂßãÂàùÂßãÂåñ');
            hookWebGL();

            // Ê∑ªÂä†Ë∞ÉËØïÂëΩ‰ª§
            unsafeWindow.showModifiedUniforms = function() {
                log('Â∑≤‰øÆÊîπÁöÑuniforms:');
                const modified = new Set();
                for (const [_, info] of uniformInfo.entries()) {
                    if (Object.values(TARGET_UNIFORMS).flat().includes(info.name)) {
                        modified.add(`${info.type}: ${info.name}`);
                    }
                }
                modified.forEach(name => log(name));
            };

            log('ÂàùÂßãÂåñÂÆåÊàê');
        } catch (error) {
            console.error('[È¢úËâ≤‰øÆÊîπÂô®] ÂàùÂßãÂåñÂ§±Ë¥•:', error);
        }
    }

    initialize();
})();

//Adding fuction
(function() {
    'use strict';

    // Create and append bottom left text
    var bottomLeftText = document.createElement('div');
    bottomLeftText.className = 'bottom-left-text';
    bottomLeftText.textContent = 'SUKI';
    document.body.appendChild(bottomLeftText);
})();

(function() {
    'use strict';

    function applyChatStyles() {
        const style = document.createElement('style');
        style.textContent = `
.chat-log-container { /* Incoming text messages */
  font-size: 20pt !important;
  padding: 0px !important;
  overflow: hidden !important;
  max-height: min(800px, 50vh) !important;
  max-width: min(800px, 50vw) !important;
}

.chat-container { /* Chat box */
  padding: 0px !important;
  background: none !important;
  position: absolute !important;
  left: 20px !important; /* Position from left edge */
  bottom: 70px !important; /* Position from bottom edge */
  transform: none !important; /* Remove any existing transforms */
}

.chat-input { /* Written text */
  font-size: 15pt !important;
  padding: 0px !important;
}

.chat-message-name { /* Message author */
  font-size: 12pt !important;
}

input::placeholder { /* Press T to write placeholder text */
  font-family: Ubuntu !important;
  font-size: 14px !important;
  text-transform: capitalize;
  visibility: hidden;
}

.chat-container.wrinkledPaper.up,
input.dialog-text-input.wrinkledPaper.chat-input,
.chat-message-container,
.chat-message-content {
  padding: 0px !important;
  background: none !important;
}


        `;
        document.head.appendChild(style);
    }

    // Apply styles when the page loads
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', applyChatStyles);
    } else {
        applyChatStyles();
    }
})();

// SCRIPT END

// This Modpack is made by SUKI.
// If you have any questions, Discord: letssukitv
// Credits: N1CN
// Links: https://suki.taplink.ws
